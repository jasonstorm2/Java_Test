package my;

/**
 * volatile 修饰符的学习：
 * volatile可以保证有序性，但不能保证原子性
 * 
 * 并发编程中的三个概念：
 * 
 * 1.原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
 * 
 * 			在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。
 * 			i= 10，是原子性。
 * 		Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。
 * 		由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。
 * 
 * 2.可见性：是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
 * 
 * 			Java提供了volatile关键字来保证可见性。
　　		当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。
　　		而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。
　　		另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，
			并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。
 * 
 * 
 * 3.有序性：即程序执行的顺序按照代码的先后顺序执行
 * 			指令重排序：一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，
 * 			它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。
 * 			重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。
 * 			指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性！！！
 * 
 * Java内存模型：规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。
 * 				 线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。
 * 				举例：i  = 10;
 　　			执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。
 
  volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
  
  volatile关键字的两层语义：
  		　	1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。

　　		2）禁止进行指令重排序。
　　			a）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；

　　			b）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。

4.volatile的原理和实现机制

　　下面这段话摘自《深入理解Java虚拟机》：

　“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”

　　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：

　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；

　　2）它会强制将对缓存的修改操作立即写入主存；

　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。

volatile关键字的场景:
	　　1）对变量的写操作不依赖于当前值

　　	2）该变量没有包含在具有其他变量的不变式中

	Volatile有五个使用场景:
	1.作为状态标志

	2.一次性安全发布

	3.独立观察

	4.volatile bean模式

	5.开销较低的读写锁策略

 * 
 * @author 李振华
 * http://www.cnblogs.com/dolphin0520/p/3920373.html
 * 
 */
public class volatileTest {
    private volatile static boolean ready;
    private static int number;
    private static class ReaderThread extends Thread {
        @Override
        public void run() {
            while(!ready) {
                Thread.yield();                
            }
            System.out.println(number);
        }
    }
    
    private static class ReaderThread2 extends Thread {
        @Override
        public void run() {
        	 number = 42;
             ready = true;
        }
    }
    
    
    public volatile int inc = 0;
    
    // volatile关键字能保证可见性没有错，但是下面的操作错在没能保证原子性,自增操作不是原子性操作，
    // inc++ 并不是原子操作，inc = inc+1; 读取变量的原始值、进行加1操作、写入工作内存
    public void increase() {
        inc++;
    }

	/**
	 * volatile 变量在多线程下的原子性测试： 多线程下，volatile不能保证变量的原子性！
	 * 
	 * 	这里面就有一个误区了，volatile关键字能保证可见性没有错
	 * ，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。
	 * 
	 * 　　在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行
	 * ，就有可能导致下面这种情况出现：
	 * 
	 * 　　假如某个时刻变量inc的值为10，
	 * 
	 * 　　线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；
	 * 
	 * 　　然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，
	 * 所以不会导致线程2的工作内存中缓存变量inc的缓存行无效
	 * ，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。
	 * 
	 * 　　然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，
	 * 所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。
	 * 
	 * 　　那么两个线程分别进行了一次自增操作后，inc只增加了1。
	 * 
	 * 　　解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对
	 * ，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，
	 * 并没有对inc值进行修改
	 * 。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。
	 * 
	 * 　　根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的
	 */
    private static void volatileAtomTest() {
    	
    	// 验证volatile变量是否原子性
    	final volatileTest test = new volatileTest();
        for(int i=0;i<10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j<1000;j++)
                        test.increase();
                };
            }.start();
        }
        while(Thread.activeCount()>1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
  

    public static void main(String[] args) {
        new ReaderThread().start();
        new ReaderThread2().start();
        volatileAtomTest();
    }
}


