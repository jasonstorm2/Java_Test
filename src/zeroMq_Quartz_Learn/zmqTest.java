package zeroMq_Quartz_Learn;


/**
 * 2016年的博客：
 * 首先，让我来介绍一下什么是ZMQ（全称：ZeroMQ）：
 * 
 * 官方： “ZMQ(以下ZeroMQ简称ZMQ)是一个简单好用的传输层，像框架一样的一个socket
 * library，他使得Socket编程更加简单、简洁和性能更高
 * 。是一个消息处理队列库，可在多个线程、内核和主机盒之间弹性伸缩。ZMQ的明确目标是“成为标准网络协议栈的一部分
 * ，之后进入Linux内核”。现在还未看到它们的成功
 * 。但是，它无疑是极具前景的、并且是人们更加需要的“传统”BSD套接字之上的一层封装。ZMQ让编写高性能网络应用程序极为简单和有趣。”
 * 
 * 与其他消息中间件相比，ZMQ并不像是一个传统意义上的消息队列服务器，事实上，它也根本不是一个服务器，它更像是一个底层的网络通讯库，在Socket
 * API之上做了一层封装，将网络通讯、进程通讯和线程通讯抽象为统一的API接口。
 * 
 * 阅读了ZMQ的Guide文档后，我觉得ZMQ是个类似于Socket的一系列接口，他跟Socket的区别是：普通的socket是端到端的（1:1的关系），
 * 而ZMQ却是可以N：M
 * 的关系，人们对BSD套接字的了解较多的是点对点的连接，点对点连接需要显式地建立连接、销毁连接、选择协议（TCP/UDP）和处理错误等
 * ，而ZMQ屏蔽了这些细节
 * ，让你的网络编程更为简单。ZMQ用于node与node间的通信，node可以是主机或者是进程。在这里我们就不细说其中常用的几个模式，
 * 以后遇到了问题会再写的。
 * 
 * 现在，我们来说一下如何在windows平台上使用ZeroMQ（java）【因为暂时只在windows平台上搭建了ZeroMQ的环境，
 * 以后使用linux的时候再来补充】
 * 
 * 众所周知，我们在git上下载的ZMQ是需要使用c的环境编译才能生成jar包和.dll文件被我们的java程序所使用的（
 * 而官网上下载的是没有build文件夹的
 * ，但是我下载的官网文件却是没有jar包的，我不知道这样如何在项目中使用，所以这条路暂且不论），但是在64bit电脑上编译的时候
 * ，编译成功率特别低（这里吐槽一下：我就没编译成功过），所以这条路很快我就放弃了（当然有志之士可以尝试一下，这样的教程也很多）。
 * 
 * 这里告诉大家我是如何成功使用的：
 * 
 * 网上会有网友分享的已经编译好的文件，一般是三个：jzmq.dll，libzmq.dll，zmq.jar文件。这时候大家就会有疑问了：
 * 我知道jar包是引入项目中的
 * ，那其他两个dll文件怎么用呢？这个网上也有很多说法，但是据我自己实践，只要将这个放在你jdk环境中即可，即：jdk放置目录/bin
 * /.dll就ok了。这样在使用ZMQ编写后项目编译时就不会报错找不到ZMQ。就此我们就可以在项目中使用ZMQ了。
 * 
 * 为了感谢当初无偿分享给我编译之后的文件的那些有爱的人们，这里我也会放出ZMQ（32bit，64bit）的文件，大家自行下载，同样也可以分享给身边有需要的人
 * ，在此谢谢。^0^（如有疑问，欢迎交流学习）
 * 
 * 下面是文件的网盘链接（如果链接被取消了，请及时与我联系！）：
 * 
 * ZMQ（java）64bit：http://pan.baidu.com/s/1boCjeiz
 * 
 * ZMQ（java）32bit：http://pan.baidu.com/s/1kUOecHD
 * 
 * 
 * 2012年的博客：
 * ZMQ之所以能够在无状态的网络中实现1对N的连接，关键在于信封的机制，信封里保存了应答目标的位置。ZMQ涉及到请求-响应模式的Socket一共有4种类型：
 * 
 * DEALER是一种负载均衡，它会将消息分发给已连接的节点，并使用公平队列的机制处理接受到的消息。
 * 
 * REQ发送消息时会在消息顶部插入一个空帧，接受时会将空帧移去。其实REQ是建立在DEALER之上的，但REQ只有当消息发送并接受到回应后才能继续运行。
 * 
 * ROUTER在收到消息时会在顶部添加一个信封，标记消息来源。发送时会通过该信封决定哪个节点可以获取到该条消息。
 * 
 * REP在收到消息时会将第一个空帧之前的所有信息保存起来
 * ，将原始信息传送给应用程序。在发送消息时，REP会用刚才保存的信息包裹应答消息。REP其实是建立在ROUTER之上的
 * ，但和REQ一样，必须完成接受和发送这两个动作后才能继续。
 * 
 *
 * ZMQ使用注意事项： ZMQ是在发送端缓存消息的，可以通过阈值控制消息的溢出；
 * ZMQ不可以线程之间共享Socket，否则会报org.zeromq.ZMQException: Operation cannot be
 * accomplished in current state错误。 ZMQ一个进程只允许有一个Context，new Context(int arg)
 * arg表示后台线程的数量；
 * ZMQ的Socket类有一个Linger参数，可以通过SetLinger设置，主要用于表示该Socket关闭以后，未发送成功的消息是否还保存
 * ，如果设置为-1
 * 表示该消息将永久保存（除非宕机，ZMQ是不持久化消息的），如果为0表示所有未发送成功的消息在Socker关闭以后都将立即清除，如果是一个正数
 * ，则表示该消息在Socket关闭后多少毫秒内被删除；这个方法非常有用，尤其在控制发送失败时，是否重发消息。
 * 
 * @author Administrator
 *
 */
public class zmqTest {

}
