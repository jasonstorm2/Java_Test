
1. 可以把类当做是一种 自定义的类型，跟基本类型比较。。在类中定义变量，称之为引用变量。也就是说，所有类都是引用类型，与数组类似。

2. static 修饰的成员 不能访问 非static修饰的成员。。。注意类 和 对象 这两个概念的区别。类变量，类方法与实例变量，实例方法的差别。
   static 的真正作用是用来区分 成员变量，方法，内部类，初始化块 这四种成员到底 属于类本身 还是 属于实例。

3. 默认构造器的意义。构造器是类创建对象的根本途径，java 语言通过 new 关键字来调用构造器，从而返回实例对象。如过一个类没有构造器，则
   java会提供一个默认的构造器。一旦程序员为类提供了构造器，系统将不再为该类提供构造器！

4. 成员变量： filed 翻译而来，又有翻译为 字段，域的。。早期有书籍称之为 属性。 然而java世界的属性property 值的是有一组 setter和getter
   方法的变量。
   
5. 构造器的返回值：构造器不能定义返回值的类型，也不能使用void声明没有返回值。实际上 构造器是有返回值的，使用new调用构造器时，
   返回的是该类的实例，因此构造器的返回值类型总是当前类，无须定义返回值类型，但不必用return来特意返回，因为构造器的返回值是 隐式的。
   
6. java 类的作用大致如下：
   1.定义变量：  Person p
   2.创建对象：  new Person();
   3.调用类的 类方法 或 访问类的 类变量： Person.globalName Person.globalMethod();
   
   java对象的作用大致如下：
   1.访问对象的 实例变量。
   2.调用对象的 方法。
   
7. 类或实例访问 方法或变量的语法是： 类.类变量|方法  实例.实例变量|方法

8. 对象，引用，指针： 引用变量里 存放的是 引用，指向实际的对象
   
   引用 放于 栈（stack）中。 对象的成员变量 放于 堆中（heap）---相像一堆对象的尸体堆放在一起
   一个对象可以有多个引用，当对象没有引用时，将被 垃圾收集器 收集处理
   
9. 对象的this引用
   this关键字总是指向 调用该方法的对象：
   1.在构造器中 引用该构造器 正在初始化的对象。（用new调用构造方法，而非用对象调用构造方法）
   2.在方法中 引用调用该方法的 对象
   
   Person.run()方法中要调用到 Person 类中的 jump()方法，使用this表示调用run的对象： this.jump()---因为非静态方法的调用，
   一定有一个对象在调用它，所以不用重新再方法中实例对象，直接用this表示调用该方法的当前对象。  
   java 允许一个对象的 成员直接调用另一个成员，所以，this关键字可以省略（注意：虽然省略了，主调是依然存在的）
   
   static 方法 由类名直接调用，如果方法中使用this，我们并不知道是哪个对象在调用，所以，static成员 不能直接访问 非static成员
   如果一定要在 static方法 中 调用 非static方法， 那么，只能实例化类，然后再调用

10. 方法 ：方法不能独立存在，必须定义在类里面，逻辑上要么属于类，要么属于对象。相对于结构化程序设计里的 函数！
    java语言是静态的？？？只要不重新编译 类文件，该类和该类的对象拥有的方法，成员永远固定不变。。。
    因为方法不能独立存在，自行运行，所以方法必须由类或者对象调用，即：类.方法|对象.方法
    
11. 调用方法：方法的调用需要传入参数的话，给形参的参数值 被称为 实参！
    方法参数的传递机制：值传递。 即 将实际参数值的副本（复制品）传入方法内，而参数本身不会受到任何影响。当系统调用方法时，系统为形参执行了初始化。    
    		方法中的变量--局部变量，是在本方法的 栈区内。不同方法在内存中拥有不同的 栈区。
    		参数传递时，被调用的方法的 栈区内 生成 该参数的副本，即，被调用的方法进行了初始化。
    		基本类型变量 复制该变量，对象 则是复制 对象的引用，不可混淆！两者其实都是 值传递！！
12. 形参个数可变的方法：
    1.JDK1.5后 java允许定义形参个数可变的 参数：在定义方法是，在 最后一个参数 的类型后，增加三个点（...），表示该形参可以接受多个参数值，
    多个参数值被当成 数组 传入。
    
13. 递归方法：一个方法体内调用它自身。递归包含了一种隐式的循环。
    递归，必须再某个时刻返回值是确定的，即，递归一定要向已知方向递归。
    
14. 方法重载：同一个类里多个同名方法，只要形参列表不同就可。
    java 确定一个方法的三个要素：
    1.调用者，对象或者类
    2.方法名，方法的标识
    3.形参列表，调用时，系统根据传入的实参列表匹配。
    
    不能根据返回值的类型来区分方法（程序员调用方法时，没有主动告诉系统返回值是什么），即，返回值不同 跟 方法重载没有任何关系。
    不推荐 重载形参长度可变的方法，没有太大意义，且容易降低程序的可读性。
    
15. 成员变量 和 局部变量--- 两者的运行机制存在较大的差异

	成员变量：定义在类里面的 变量，filed 有static 非static之分，是类或者实例中的一个成员，所以称为成员变量，与类或实例共存亡。
	即 类成员变量，实例成员变量；只要类存在，程序就可以访问类变量；只要 实例存在，程序就可以访问实例变量
	   
	局部变量：
		方法局部变量（在方法内定义），		--从定义处到方法结束 有效 ， 必须 显示初始化 ----成员变量可以不用显示初始化，系统默认初始
		形参（方法签名中定义的变量），		--整个方法有效				 调用时就初始化了
		代码块局部变量（在方法内部的代码块）（在代码块内定义）	--从定义处到代码块结束 有效，必须 显示初始化
	
	成员变量 无需显式的初始化，或者在声明时定义，类在加载时给予 默认值。
	
	命名规则：如果先定义方法内代码块的 局部变量，后定义 方法的局部变量，两个名字可以相同，否则不行。
	    局部变量名字 可以 和 成员变量名字 相同。后果是，局部变量覆盖成员变量。如果不想覆盖，可以用 this.或类. 来引用成员变量。
	
16. 成员变量的初始化 和 在内存中的运行机制
	类变量: 	在类加载时，	在堆内存，系统为该变量分配内存空间（类对象），		并指定默认值。 类变量 独立于 对象
	
	实例变量： 	在 实例创建时，	在堆内存，系统为该实例变量 分配内存空间（实例对象），并指定默认值  此时，并不再为类变量分配空间（类变量的独立性）

17. 局部变量的初始化 和 在内存中的运行机制
	局部变量必须初始化才能使用，系统不会自动为 局部变量 执行初始化：这意味着，定义局部变量，系统并未为这个变量分配内存空间！！
	局部变量 不属于 类或实例：调用方法时，程序给变量赋初始值，系统才会为 局部变量分配内存，并将值保存于此。而此内存是在 方法的栈内存中！！
	
	栈内存中的变量 无须 系统垃圾回收，随着方法或代码块结束而结束！！
	
	局部变量 只保存基本类型 和 对象引用，所以 所占内存区 通常比较小！！
	
18.隐藏 和 封装 
   对象变量 放于堆内存中，对其进行适当的封装，别的类或对象 无法直接访问 该对象的变量，只能通过该对象的特定方法 访问和修改。
   隐藏该隐藏的 变量或方法， 暴露该暴露的 变量或方法。
   
   访问控制符： private （default） protected public
   
   private   ：  同类
   default   ：  同类   同包						------->同一个包中，不用使用 import 引用 这个类。
   protected :   同类   同包  子类
   public     :  同类   同包  子类  全局范围
   
   局部变量 不用 访问控制符 修饰。（其作用域就在本方法内）
   外部类 只能有 public 或 default 两种访问控制级别。
   一个源文件 只能拥有一个public类，且 源文件名与该类名 相同
   
   javaBean 每个成员变量都是private，对应都有setter 和 getter
   
19. package,import,import static
    为了防止类名重复引起问题，引入包（package）机制，提供类的 多层命名空间，用于解决类名冲突，类文件管理等问题。
    相同功能的类，放于同一个package下，组成类库单元。
    把类放于指定的包结构下： 源程序第一个 非注释行 声明引入包: package packageName;
    
    javac -d . Hello.java 生成的.class文件 所在的 文件系统 要与 包名层次 相同的 目录结构。
    javac Hello.java 则不会生成包结构。    
    所以：-d 会为class文件生成相应的文件结构，建议不能省略 -d
    
    java规定：位于包中的类，在文件系统中 也必须有与 包名层次 相同的目录结构！
    
    常见问题：
    在生成的class文件路径中。在包所在的目录 执行 java lee.Hello 正常
    而，进入lee包后 使用 java Hello 则错误。。。
    原因：Hello类带包名， java这个命令会根据 包名.类名 类执行，如果进入lee包，则失去了包名，所以会出错
    
    虚拟机加载类，首先会一次搜错 CLASSPATH环境变量所指定的 系列路径，查找这些路径手否含有 某个包，在查找包中是否含有 某各类。
    同一个包的两个类，不一定要在同一个位置，可以一个在C，一个在D，只要 CLASSPATH环境变量 包含这两个路径即可！！！
    但，预防忘却和混乱，最好在同一个地方！！！
    
    java中，并不是class文件放于某个目录下，此目录就变成包名，java包机制 需要两个方面保证：
    1.源文件里 使用package 语句指定包名。
    2.class文件必须放在对应的路径下。
    
    包名也有可能重复：Oracle 建议用 公司的Internel域名 倒写作为 包名，如：com.baidu
    
    如果没有指定包名，则 类会放在 默认包 中。
    同一个包的类，可以自由访问，无需添加 前缀！！即，无需 import
    包 的 子包类内，java源文件名 必须也是 包名.类名，不能省去父包 的名字：语法上不错在任何关系，都是独立的包结构。
    
    创建其他包中的类实例，必须使用包前缀，或者 import 该类。import 包名.类名。。。也可以导入包的全部类：import 包名.* ---子包里面的类是不会导入的
    
    java 默认为所有源文件导入 java.lang 包下 所有的类。
    
    import static：静态导入，导入静态成员变量 或者 方法。
    与 import 的区别：import可以省略包名，import static 连类名都可以省略。
    
20.深入构造器
    
    
    
    
    
    
    
    
    
    








  
   
   
   